package com.leetcode.btree;

public class Hello {
/*
树和递归

大家知道，树这种数据结构中最经典的应用自当是二叉树。二叉树具备天然的递归结构，因此，
二叉树相关的大部分题目当中，都可以运用递归这种思想解决问题。

这里简单地谈一谈如何设计一个递归算法：
你需要深刻地认识“递”和“归”这两个字，“递”意味着传递，因此在设计时，你要明白你的代码如何传递到
所有子问题；“归”意味着边界条件，递归程序必须在适当的时候返回，如何考虑返回条件，来达成最终的结果，
掌握这两个字，就能更加深入地理解递归这个思想的精髓。

------------------------------------------------------------------

二叉树01（队列） - 二叉树的层序遍历 - 中等 - 102

给定一个二叉树，返回其层序遍历结构（从左往右，一层一层地遍历）。

比如： 给定二叉树 [3, 9 , 20 , null, null, 15, 7]，
    3
   / \
  9  20
    /  \
   15   7
返回的结果应该是：
[
    [3],
    [9, 20],
    [15, 7]
]

-----------------------------------------------------------------


二叉树02（队列） - 从右侧观察二叉树的结果 - 中等 - 199

给定一棵二叉树，相信你站在树的右边观察它，返回你能看到的结点，顺序为自上而下：

比如：
   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
应该返回[1, 3, 4]

-----------------------------------------------------------------

二叉树03 - 二叉树最低深度 - 简单 - 111

求一棵二叉树的最低深度，也就是从根节点到叶子结点的最短路径的长度。

二叉树04 - 反转二叉树 - 简单 - 226

这个题目大有来头~当年homebrew的作者去面试Google，就是因为这道基础题做不出来被pass掉了，这在业界曾经引起了广泛的反响。

Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.

反转二叉树。
原树：
     4
   /   \
  2     7
 / \   / \
1   3 6   9
反转后：
     4
   /   \
  7     2
 / \   / \
9   6 3   1

-----------------------------------------------------------------

二叉树05 - 判断二叉树是否对称 - 简单 - 101

给定一棵二叉树，检查它是否为对称的。

比如：
    1
   / \
  2   2
 / \ / \
3  4 4  3
是一棵对称的二叉树，而
    1
   / \
  2   2
   \   \
   3    3
则为非对称。

注意：
尝试用递归和迭代两种方式解决。

-----------------------------------------------------------------

二叉树06 - 计算完全二叉树的节点个数 - 中等 - 222

给定一个完全二叉树，求它的节点个数。

概念：
完全二叉树： 除了最后一层，其他所有层的节点数达到最大，同时最后一层的所有节点都在最左侧。

满二叉树： 所有节点数达到最大。

-----------------------------------------------------------------

二叉树07 - 判断一棵二叉树是否为平衡二叉树 - 简单 - 110

判断一棵二叉树是否为平衡二叉树。

平衡二叉树： 每一个节点的左右子树的高度差不超过1。

-----------------------------------------------------------------

二叉树08 - 路径和 - 简单 - 112

给出一棵二叉树以及一个数字sum，判断在这棵二叉树上是否存在一条从根节点到叶子的路径，
其路径上的所有节点和为sum。

技巧：如何在递归过程中保存数据。

比如：
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
如果sum = 22，则可以找到这条路径满足条件： 5->4->11->2。

-----------------------------------------------------------------

二叉树09 - 左叶子的和 - 简单 - 404

找到树中所有左叶子的和。

比如：
    3
   / \
  9  20
    /  \
   15   7
这棵树中有两个左叶子，9和15，因此返回结果应该为24。

-----------------------------------------------------------------

二叉树10 - 二叉树路径 - 简单 - 257

给定一棵二叉树，返回所有表示从根节点到叶子结点路径的字符串。

技巧：如何利用递归函数的返回值。

如：
   1
 /   \
2     3
 \
  5
返回结果为：
["1->2->5", "1->3"]

-----------------------------------------------------------------

二叉树11 - 根节点到叶子结点的和 - 简单 -  129

给定一棵二叉树，每个节点都是一个0-9的数字。从根节点到叶子结点的每条路径可以表示成一个数，
求这些数的和。

比如：
    1
   / \
  2   3

1->2，可以表示成12；
1->3，可以表示成13；
所以结果为12+13=25。

-----------------------------------------------------------------

二叉树12 - 路径和3 - 简单 - 437

技巧：更加复杂的递归逻辑。

给出一棵二叉树以及一个数字sum，判断二叉树上存在多少条路径，使其路径上的所有节点的和为sum。

注意：
* 其中路径不一定要起始于根节点、终止于叶子结点。
* 路径虽然可以从任意节点开始，但只能往下走。

-----------------------------------------------------------------

二叉树13（二分搜索树） - 二叉搜索树中的最近公共祖先 - 简单 - 235

给定一棵二叉搜索树和两个节点，寻找这两个节点的最近公共祖先。

比如：
        _______6______
       /              \
    ___2__          ___8__
   /      \        /      \
   0      _4       7       9
         /  \
         3   5

给定2和8，则结果为6。给定2和4则结果为2。

-----------------------------------------------------------------

二叉树14（二分搜索树） - 在二分搜索树中删除一个节点 - 中等 - 450

给定一个二分搜索树，删除其中一个节点。

一般来说，删除操作可以分为两个不走：
1. 查找到要删除的那个节点
2. 如果找到，则删除它。

注意：
时间复杂度至少得小于等于O(树的高度)

比如：

root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7

给定要删除的节点为3。
其中一个可行的答案为[5,4,6,2,null,null,7]，如下：

    5
   / \
  4   6
 /     \
2       7

另一种有效的答案为 [5,2,6,null,4,null,7].

    5
   / \
  2   6
   \   \
    4   7

-----------------------------------------------------------------

二叉树15（二分搜索树） - 将有序数组转换为一颗平衡的二叉搜索树 - 简单 - 108

给定一个有序数组，生成一棵平衡的二叉搜索树。

-----------------------------------------------------------------
 */
}
